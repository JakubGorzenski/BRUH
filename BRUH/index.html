<canvas id='canvas' style='height:100%; image-rendering: pixelated;'></canvas>

<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script>
<script>

//  what do these fellas do?
const decode = new TextDecoder("utf-8");
const encode = new TextEncoder("utf-8");

var ctx = null;
var memory = null;
var wasm = null;

var c_arguments = [];

var key_translation = {
    ["PrintScreen"] : 23,
    ["ScrollLock"]  : 24,
    ["Pause"] : 25,

    ["Backspace"] : 8,
    ["Tab"] : 9,
    ["Enter"] : 10,
    ["CapsLock"] : 26,
    ["Escape"] : 27,
    ["Meta"] : 28,

    [" "] : 32,

    ["!"] : 49,
    ["@"] : 50,
    ["#"] : 51,
    ["$"] : 52,
    ["%"] : 53,
    ["^"] : 54,
    ["&"] : 55,
    ["*"] : 56,
    ["("] : 57,
    [")"] : 48,

    ["_"] : 45,
    ["+"] : 43,
    ["{"] : 123,
    ["|"] : 124,
    ["}"] : 125,
    [":"] : 59,
    ["\""]: 34,
    ["<"] : 44,
    [">"] : 46,
    ["?"] : 47,

    ["Insert"] : 33,
    ["Home"] : 34,
    ["PageUp"] : 35,
    ["Delete"] : 36,
    ["End"] : 37,
    ["PageDown"] : 38,

    ["Shift"] : 0x29,
    ["Control"] : 0x2a,
    ["Alt"] : 0x2c,

    ["ArrowLeft"] : 60,
    ["ArrowRight"] : 62,
    ["ArrowUp"] : 94,
    ["ArrowDown"] : 118,

    ["NumLock"] : 39,
};



var importObject = {
    internal_bruh_print(str, length) {
        var enc = new TextDecoder("utf-8");
        var str = new Int8Array(memory.buffer, str, length);
        console.log(enc.decode(str));
    },

    internal_bruh_js_init(keyboard_ptr, kbp_size) {
        for(i = 1; i <= 12; i++)    //  F1 to F12
            key_translation['F' + i] = 10 + i;
        for(i = 45; i <= 57; i++)   //  - to 9
            key_translation[String.fromCharCode(i)] = i;
        for(i = 65; i <= 93; i++)   //  A to ]
            key_translation[String.fromCharCode(i)] = i;
        for(i = 97; i <= 122; i++)   //  a to z
            key_translation[String.fromCharCode(i)] = i - 32;

        var keyboard;
        keyboard = new Int32Array(memory.buffer, keyboard_ptr, kbp_size);

        addEventListener("keydown", (event) => {
            event.preventDefault();

            if(event.repeat)
                return;
            keyboard[key_translation[event.key]] = 1;
            keyboard['?'.charCodeAt(0)] = key_translation[event.key];
            
            if(event.key.length == 1)
                keyboard['|'.charCodeAt(0)] = event.key.charCodeAt(0);
            if(event.key == "Backspace")
                keyboard['|'.charCodeAt(0)] = 8;
            if(event.key == "Tab")
                keyboard['|'.charCodeAt(0)] = 9;
            if(event.key == "Enter")
                keyboard['|'.charCodeAt(0)] = 10;
        });
        addEventListener("keyup", (event) => {
            keyboard[key_translation[event.key]] = -1;
        });
    },

    internal_bruh_send_name_js(name, length) {    //  implement all this stuff
        c_arguments[0] = decode.decode(new Int8Array(memory.buffer, name, length));
    },
    internal_bruh_send_buffer_js(start, length) {    //  implement all this stuff
        c_arguments[1] = new Int8Array(memory.buffer, start, length);
    },
    
    //  stuff for listing files
    //  https://developer.mozilla.org/en-US/docs/Web/API/FileSystemDirectoryHandle/keys
    //  async so cannot return anything :C
    async internal_bruh_file_load(index) {
        try {
            var file_name = c_arguments[0];
            c_arguments = [];

            var names = file_name.split("/");
            if(names[0] != "ROM") {
                var dir = await navigator.storage.getDirectory();
                //console.log(dir);
                var i = 0;
                for(; i < names.length - 1; i++) {
                    dir = await dir.getDirectoryHandle(names[i]);
                }
                //console.log(dir);
                var file = await dir.getFileHandle(names[i])
                file = await file.getFile()
                file = await file.arrayBuffer();
                file = new Int8Array(file);

                //console.log(file, index, file.length);

                var buffer = wasm.internal_bruh_file_allocate(index, file.length);

                //console.log(buffer);
                if(buffer != 0) {
                    for(var i = 0; i < file.length; i++) {
                        memory[buffer + i] = file[i];
                    }
                }
            } else {
                download(file_name).then((file) => {
                    var buffer = wasm.internal_bruh_file_allocate(index, file.data.length);

                    for(var i = 0; i < file.data.length; i++) {
                        memory[buffer + i] = file.data[i];
                    }
                });
            }
        } catch(error) {
            wasm.internal_bruh_file_allocate(index, 0);
            if(error.name != "NotFoundError") {
                //alert("BRUH: can't load a file because\n" + error.message);
                console.error(error);
            }
        }
        wasm.internal_bruh_file_transfer_complete();
    },
    async internal_bruh_file_save() {
        var names = c_arguments[0].split("/");
        var save = c_arguments[1];
        c_arguments = [];

        try {
            if(names[0] != "ROM") {
                var dir = await navigator.storage.getDirectory();

                var i = 0;
                for(; i < names.length - 1; i++) {
                    //console.log(names[i], dir);
                    dir = await dir.getDirectoryHandle(names[i], {create: true});
                }
                //console.log(names[i], dir);
                var file_handle = await dir.getFileHandle(names[i], {create: true});
                //console.log(file_handle);
                var file = await file_handle.createWritable();

                //console.log(save)
                //console.log(save.buffer);
                //console.log(file);
                await file.write(save);
                //console.log(file);

                await file.close();
            } else {
                alert("BRUH: can't save to ROM/");
                //  report error!
            }
        } catch(error) {
            alert("BRUH: can't save a file because\n" + error.message);
            console.error(error);
        }
        wasm.internal_bruh_file_transfer_complete();
    },
    async internal_bruh_file_append() {
        var names = c_arguments[0].split("/");
        var append = c_arguments[1];
        c_arguments = [];

        try {
            if(names[0] != "ROM") {
                var dir = await navigator.storage.getDirectory();

                var i = 0;
                for(; i < names.length - 1; i++) {
                    dir = await dir.getDirectoryHandle(names[i], {create: true});
                }
                var file = await dir.getFileHandle(names[i], {create: true});
                var file_size = (await file.getFile()).size;
                file = await file.createWritable({keepExistingData: true});

                //console.log(file_size);

                await file.write({type: "write", data: append, position: file_size});
                await file.close();
            } else {
                alert("BRUH: can't append to a file in ROM/");
                //  report error!
            }
        } catch(error) {
            alert("BRUH: can't append to a file because\n" + error.message);
            console.error(error);
        }
        wasm.internal_bruh_file_transfer_complete();
    },
    async internal_bruh_file_delete() {
        var names = c_arguments[0].split("/");
        c_arguments = [];

        try {
            if(names[0] != "ROM") {
                var dir = await navigator.storage.getDirectory();

                var i = 0;
                for(; i < names.length - 1; i++) {
                    dir = await dir.getDirectoryHandle(names[i], {create: true});
                }
                dir.removeEntry(names[i]);
            } else {
                alert("BRUH: can't delete from ROM/");
                //  report error!
            }
        } catch(error) {
            alert("BRUH: can't delete a file because\n" + error.message);
            console.error(error);
        }
    },
    /*internal_bruh_file_set_target(name, length) {
        var str = new Int8Array(memory.buffer, name, length);

        target_file.name = decode.decode(str);
        if(downloaded_files[target_file.name])  //  added, check if works
            target_file.data = encode.encode(downloaded_files[target_file.name]);
        else
            target_file.data = encode.encode(window.localStorage.getItem(target_file.name));
        return target_file.data.length;
    },
    internal_bruh_file_load(buffer) {
        for(var i = 0; i < target_file.data.length; i++) {
            memory[buffer + i] = target_file.data[i];
        }
        return save_target_file();
    },
    internal_bruh_file_save(save, length) {
        target_file.data = new Int8Array(length);
        for(var i = 0; i < length; i++) {
            target_file.data[i] = memory[save + i];
        }
        return save_target_file();
    },
    internal_bruh_file_append(append, length) {
        var concat = new Uint8Array(target_file.data.length + length);
        concat.set(target_file.data);
        var app = new Uint8Array(memory.buffer, append, length);
        concat.set(app, target_file.data.length);
        target_file.data = concat;
        return save_target_file();
    },
    internal_bruh_file_delete() {
        window.localStorage.removeItem(target_file.name);
        return 1;
    },
    */

    internal_bruh_output(buffer, w, h) {
        var bruh_screen = new ImageData(
                new Uint8ClampedArray(
                memory.subarray(buffer, buffer + w * h * 4)), w, h);
        ctx.canvas.width = w;
        ctx.canvas.height = h;
        ctx.putImageData(bruh_screen, 0, 0);
    },
};



function js_main(ms_time) {
    if(wasm._start(ms_time) != -1)
        requestAnimationFrame(js_main);
}


function download(file_name) {
    var request = {
        url: file_name, //  can't contain spacec (maybe?)
        error: () => { return new ArrayBuffer(0); },
        success: (data) => { return data; },
        xhr: () => {
            var xhrOverride = new XMLHttpRequest();
            xhrOverride.responseType = 'arraybuffer';
            return xhrOverride;
        }
    };
    return $.when($.ajax(request));
}

download("ROM/main.wasm").then((main_wasm) => {
    WebAssembly.instantiate(
        main_wasm,
        { env: importObject },
    ).then((res) => {
        wasm = res.instance.exports;    //  see if this is preserved after grow (stoopid js...)

        var old_size = wasm.memory.grow(0);
        var grow_ret = wasm.memory.grow(65536 - old_size);
        var new_size = wasm.memory.grow(0);
        console.log(old_size, grow_ret, new_size);

        memory = new Uint8Array(wasm.memory.buffer);

        wasm.internal_bruh_wasm_init(old_size, new_size - old_size);

        ctx = document.getElementById("canvas").getContext('2d', { alpha: false });
        requestAnimationFrame(js_main);
    });
})

</script>
